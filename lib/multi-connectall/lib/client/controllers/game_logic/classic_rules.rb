  module GameLogic
    class ClassicRules < Rules
      attr_accessor :game_state_model, :grid

      ## 
      # Game rules for classic mode
      # Win condition: four in a row, in any space.
      # Dev: bitboard interaction for CPU

    def initialize(game_state_model)
      @game_state_model = game_state_model
      @grid = @game_state_model::grid.getGrid
      @winner = nil

      @masks = {
         1 => 0b0000000000000000000000000000000000000000000000000000000000000001,
         2 => 0b0000000000000000000000000000000000000000000000000000000000000010,
         3 => 0b0000000000000000000000000000000000000000000000000000000000000100,
         4 => 0b0000000000000000000000000000000000000000000000000000000000001000,
         5 => 0b0000000000000000000000000000000000000000000000000000000000010000,
         6 => 0b0000000000000000000000000000000000000000000000000000000000100000,
         7 => 0b0000000000000000000000000000000000000000000000000000000001000000,
         8 => 0b0000000000000000000000000000000000000000000000000000000010000000,
         9 => 0b0000000000000000000000000000000000000000000000000000000100000000,
        10 => 0b0000000000000000000000000000000000000000000000000000001000000000,
        11 => 0b0000000000000000000000000000000000000000000000000000010000000000,
        12 => 0b0000000000000000000000000000000000000000000000000000100000000000,
        13 => 0b0000000000000000000000000000000000000000000000000001000000000000,
        14 => 0b0000000000000000000000000000000000000000000000000010000000000000,
        15 => 0b0000000000000000000000000000000000000000000000000100000000000000,
        16 => 0b0000000000000000000000000000000000000000000000001000000000000000,
        17 => 0b0000000000000000000000000000000000000000000000010000000000000000,
        18 => 0b0000000000000000000000000000000000000000000000100000000000000000,
        19 => 0b0000000000000000000000000000000000000000000001000000000000000000,
        20 => 0b0000000000000000000000000000000000000000000010000000000000000000,
        21 => 0b0000000000000000000000000000000000000000000100000000000000000000,
        22 => 0b0000000000000000000000000000000000000000001000000000000000000000,
        23 => 0b0000000000000000000000000000000000000000010000000000000000000000,
        24 => 0b0000000000000000000000000000000000000000100000000000000000000000,
        25 => 0b0000000000000000000000000000000000000001000000000000000000000000,
        26 => 0b0000000000000000000000000000000000000010000000000000000000000000,
        27 => 0b0000000000000000000000000000000000000100000000000000000000000000,
        28 => 0b0000000000000000000000000000000000001000000000000000000000000000,
        29 => 0b0000000000000000000000000000000000010000000000000000000000000000,
        30 => 0b0000000000000000000000000000000000100000000000000000000000000000,
        31 => 0b0000000000000000000000000000000001000000000000000000000000000000,
        32 => 0b0000000000000000000000000000000010000000000000000000000000000000,
        33 => 0b0000000000000000000000000000000100000000000000000000000000000000,
        34 => 0b0000000000000000000000000000001000000000000000000000000000000000,
        35 => 0b0000000000000000000000000000010000000000000000000000000000000000,
        36 => 0b0000000000000000000000000000100000000000000000000000000000000000,
        37 => 0b0000000000000000000000000001000000000000000000000000000000000000,
        38 => 0b0000000000000000000000000010000000000000000000000000000000000000,
        39 => 0b0000000000000000000000000100000000000000000000000000000000000000,
        40 => 0b0000000000000000000000001000000000000000000000000000000000000000,
        41 => 0b0000000000000000000000010000000000000000000000000000000000000000,
        42 => 0b0000000000000000000000100000000000000000000000000000000000000000,
        43 => 0b0000000000000000000001000000000000000000000000000000000000000000,
        44 => 0b0000000000000000000010000000000000000000000000000000000000000000,
        45 => 0b0000000000000000000100000000000000000000000000000000000000000000,
        46 => 0b0000000000000000001000000000000000000000000000000000000000000000,
        47 => 0b0000000000000000010000000000000000000000000000000000000000000000,
        48 => 0b0000000000000000100000000000000000000000000000000000000000000000,
        49 => 0b0000000000000001000000000000000000000000000000000000000000000000,
        50 => 0b0000000000000010000000000000000000000000000000000000000000000000,
        51 => 0b0000000000000100000000000000000000000000000000000000000000000000,
        52 => 0b0000000000001000000000000000000000000000000000000000000000000000,
        53 => 0b0000000000010000000000000000000000000000000000000000000000000000,
        54 => 0b0000000000100000000000000000000000000000000000000000000000000000,
        55 => 0b0000000001000000000000000000000000000000000000000000000000000000,
        56 => 0b0000000010000000000000000000000000000000000000000000000000000000,
        57 => 0b0000000100000000000000000000000000000000000000000000000000000000,
        58 => 0b0000001000000000000000000000000000000000000000000000000000000000,
        59 => 0b0000010000000000000000000000000000000000000000000000000000000000,
        60 => 0b0000100000000000000000000000000000000000000000000000000000000000,
        61 => 0b0001000000000000000000000000000000000000000000000000000000000000,
        62 => 0b0010000000000000000000000000000000000000000000000000000000000000,
        63 => 0b0100000000000000000000000000000000000000000000000000000000000000,
        64 => 0b1000000000000000000000000000000000000000000000000000000000000000
      }

    end

    # def win
    #   return has_won(construct_bitboard(@game_state_model::grid,1))
    # end
  
    ## 
    # Checks if player has won for any vertical
    # Inputs: none
    # Outputs: boolean

    def check_vertical
      RulesContracts.classic_model(@game_state_model)
      (0..7).each { |y|
        (0..7).each { |x|
          if y < 5 and @grid[y][x] == 2
            if @grid[y + 1][x] == 2 and @grid[y + 2][x] == 2 and @grid[y + 3][x] == 2
              @winner = 1
              return true
            end
          elsif y < 5 and @grid[y][x] == 1
            if @grid[y + 1][x] == 1 and @grid[y + 2][x] == 1 and @grid[y + 3][x] == 1
              @winner = 0
              return true
            end
          end  
        }
      }
      return false
    end

    ## 
    # Checks if a player has won for any horizontal
    # Inputs: none
    # Outputs: boolean

    def check_horizontal
      RulesContracts.classic_model(@game_state_model)
      (0..7).each { |y|
        (0..7).each { |x|
          if x < 5 and @grid[y][x] == 2
            if @grid[y][x + 1] == 2 and @grid[y][x + 2] == 2 and @grid[y][x + 3] == 2
              @winner = 1
              return true
            end
          elsif x < 5 and @grid[y][x] == 1
            if @grid[y][x + 1] == 1 and @grid[y][x + 2] == 1 and @grid[y][x + 3] == 1
              @winner = 0
              return true
            end
          end   
        }
      }
      return false
    end

    ## 
    # Checks if a player has won for any diagonal
    # Inputs: none
    # Outputs: boolean

    def check_diagonal
      RulesContracts.classic_model(@game_state_model)
      # testing for bitboard errors
      # (0..7).each { |y|
      #  (0..7).each { |x|
      #    if @grid[y][x] == 1 and y <= 4 and x >= 3
      #      puts " #{x}/#{y}  #{@grid[y][x]} || #{x-1}/#{y+1}  #{@grid[y + 1][x - 1]} || #{x-2}/#{y+2} #{@grid[y + 2][x - 2]} || #{x-3}/#{y+3} #{@grid[y + 3][x - 3]}"
      #      puts "#{@grid[y][x] == 1 and @grid[y + 1][x - 1] == 1 and @grid[y + 2][x - 2] == 1 and @grid[y + 3][x - 3] == 1}"
      #    end
      #  }
      # }
      
      (0..7).each { |y|
        (0..7).each { |x|
          if y <= 4 and x <= 4
            if @grid[y][x] == 2 and @grid[y + 1][x + 1] == 2 and @grid[y + 2][x + 2] == 2 and @grid[y + 3][x + 3] == 2
              @winner = 1
              return true
            elsif @grid[y][x] == 1 and @grid[y + 1][x + 1] == 1 and @grid[y + 2][x + 2] == 1 and @grid[y + 3][x + 3] == 1
              @winner = 0
              return true
            end 
          end
          if y <= 4 and x >= 3
            if @grid[y][x] == 2 and @grid[y + 1][x - 1] == 2 and @grid[y + 2][x - 2] == 2 and @grid[y + 3][x - 3] == 2
              @winner = 1
              return true
            elsif @grid[y][x] == 1 and @grid[y + 1][x - 1] == 1 and @grid[y + 2][x - 2] == 1 and @grid[y + 3][x - 3] == 1
              @winner = 0
              return true
            end
          end
          if y >= 3 and x <= 4
            if @grid[y][x] == 2 and @grid[y - 1][x + 1] == 2 and @grid[y - 2][x + 2] == 2 and @grid[y - 3][x + 3] == 2
              @winner = 1
              return true
            elsif @grid[y][x] == 1 and @grid[y - 1][x + 1] == 1 and @grid[y - 2][x + 2] == 1 and @grid[y - 3][x + 3] == 1
              @winner = 0
              return true
            end 
          end
          if y >= 3 and x >= 3
            
            if @grid[y][x] == 2 and @grid[y - 1][x - 1] == 2 and @grid[y - 2][x - 2] == 2 and @grid[y - 3][x - 3] == 2
              @winner = 1
              return true
            elsif @grid[y][x] == 1 and @grid[y - 1][x - 1] == 1 and @grid[y - 2][x - 2] == 1 and @grid[y - 3][x - 3] == 1
              @winner = 0
              return true
            end 
          
          end  
        }
      }
      return false
    end

    ## 
    # Given the board, identifies if a player has won
    # Inputs: bitboard
    # Outputs: boolean

    def has_won(board)
      # printf("Pre-Solved: %b \n", board)
      # puts "Num: #{board}"
      # check \ diagonal
      w = board & (board >> 7)
      # check -- horizontal
      x = board & (board >> 8)
      # check / diagonal
      y = board & (board >> 9)
      # check | vertical
      z = board & (board >> 1)

      bitboard = ( (w & (w >> (2 * 7))) |
               (x & (x >> (2 * 8))) |
              (y & (y >> (2 * 9))) |
               (z & (z >> (2 * 1)))    )
      # printf("Solved: %b \n", bitboard)
      # puts @game_state_model::state
      return  bitboard > 0
    end

    ## 
    # Generates bitboard for player specific interactions
    # Inputs: grid, player (or AI)
    # Outputs: bitboard

    def construct_bitboard(grid, player_num)
      board = 0b0000000000000000000000000000000000000000000000000000000000000000

      counter = 1
      (1..8).each do |col|
        (1..8).each do |row|
          if grid.getValue(col-1, 8-row) == player_num
            board =  @masks[counter] | board
          end
          counter = counter + 1
        end
      end
      printf("For #{player_num}: Bitboard %b \n", board)
      return board
    end

  end # classicRules

end #gamelogic